// Copyright 2025 DataRobot, Inc. and its affiliates.
// All rights reserved.
// DataRobot, Inc. Confidential.
// This is unpublished proprietary source code of DataRobot, Inc.
// and its affiliates.
// The copyright notice above does not evidence any actual or intended
// publication of such source code.

package dotenv

import (
	"os"
	"regexp"
	"slices"
	"strings"
	"time"

	"github.com/charmbracelet/log"
)

var defaultEnvTemplate = `DATAROBOT_ENDPOINT=
DATAROBOT_API_TOKEN=

USE_DATAROBOT_LLM_GATEWAY=
`

func backup(dotenvFile string) error {
	if _, err := os.Stat(dotenvFile); err == nil {
		backupFile := dotenvFile + ".backup." + time.Now().Format("2006-01-02_15-04-05")

		err = os.Rename(dotenvFile, backupFile)
		if err != nil {
			return err
		}

		log.Info("Backing up " + dotenvFile + " as " + backupFile)
	}

	return nil
}

func readTemplate(dotenvFile string) ([]string, string) {
	templateFiles := []string{
		dotenvFile,
		dotenvFile + ".sample",
		dotenvFile + ".template",
	}

	for _, templateFile := range templateFiles {
		templateContents, err := os.ReadFile(templateFile)
		if err != nil {
			log.Debug(err)
			continue
		}

		if len(templateContents) == 0 {
			continue
		}

		log.Info("Using " + templateFile + " as template")

		return slices.Collect(strings.Lines(string(templateContents))), templateFile
	}

	return slices.Collect(strings.Lines(defaultEnvTemplate)), ""
}

func variablesFromTemplate(templateLines []string) ([]variable, string, bool) {
	variables := make([]variable, 0)
	changed := false

	var contents strings.Builder

	for _, templateLine := range templateLines {
		v := newFromLine(templateLine)

		if v.name != "" && v.commented {
			variables = append(variables, v)
		}

		if v.name == "" || v.commented {
			contents.WriteString(templateLine)
			continue
		}

		v.setValue()

		if v.changed {
			changed = true
		}

		if v.value == "" {
			contents.WriteString(templateLine)
		} else {
			log.Info("Adding variable " + v.name)
			contents.WriteString(v.String())
		}

		variables = append(variables, v)
	}

	return variables, contents.String(), changed
}

// parseVariablesOnly parses variables from template lines without attempting to auto-populate them.
// This is used when the user manually edits the file to avoid unnecessary API calls and errors.
func parseVariablesOnly(templateLines []string) []variable {
	variables := make([]variable, 0)

	for _, templateLine := range templateLines {
		v := newFromLine(templateLine)

		if v.name != "" {
			variables = append(variables, v)
		}
	}

	return variables
}

func writeUsingTemplateFile(dotenvFile string) ([]variable, string, string, error) {
	templateLines, templateFileUsed := readTemplate(dotenvFile)

	variables, contents, anyChanged := variablesFromTemplate(templateLines)

	if anyChanged {
		err := backup(dotenvFile)
		if err != nil {
			return nil, "", "", err
		}
	}

	err := writeContents(contents, dotenvFile, templateFileUsed)
	if err != nil {
		return nil, "", "", err
	}

	return variables, contents, templateFileUsed, nil
}

func writeContents(contents, dotenvFile, templateFile string) error {
	f, err := os.Create(dotenvFile)
	if err != nil {
		return err
	}
	defer f.Close()

	var header string
	if templateFile == "" {
		header = "# Autogenerated by dr dotenv\n\n"
	} else {
		header = "# Autogenerated by dr dotenv from " + templateFile + " file\n\n"
	}

	re := regexp.MustCompile(`# Autogenerated by dr dotenv[^\n]*\n\n`)

	if re.MatchString(contents) {
		contents = re.ReplaceAllLiteralString(contents, header)
	} else {
		contents = header + contents
	}

	_, err = f.WriteString(contents)
	if err != nil {
		return err
	}

	return nil
}
