// Copyright 2025 DataRobot, Inc. and its affiliates.
// All rights reserved.
// DataRobot, Inc. Confidential.
// This is unpublished proprietary source code of DataRobot, Inc.
// and its affiliates.
// The copyright notice above does not evidence any actual or intended
// publication of such source code.

package dotenv

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"sort"
	"strings"
	"time"

	"github.com/charmbracelet/log"
)

const (
	// File extensions and suffixes
	backupSuffix   = ".backup."
	sampleSuffix   = ".sample"
	templateSuffix = ".template"

	// Time formats
	backupTimeFormat = "2006-01-02_15-04-05"

	// Header comment prefixes
	headerPrefixAutogen = "# Autogenerated by dr dotenv"
	headerPrefixEdited  = "# Edited using `dr dotenv`"

	// Common variable names
	datarobotEndpointVar = "DATAROBOT_ENDPOINT"
)

var defaultEnvTemplate = `DATAROBOT_ENDPOINT=
DATAROBOT_API_TOKEN=

USE_DATAROBOT_LLM_GATEWAY=
`

// getStateDir returns the XDG_STATE_HOME directory for the dr app
func getStateDir() (string, error) {
	stateDir := os.Getenv("XDG_STATE_HOME")
	if stateDir == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return "", fmt.Errorf("failed to get user home directory: %w", err)
		}
		stateDir = filepath.Join(homeDir, ".local", "state")
	}
	
	drStateDir := filepath.Join(stateDir, "dr", "backups")
	if err := os.MkdirAll(drStateDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create state directory: %w", err)
	}
	
	return drStateDir, nil
}

// getBackupBaseName creates a unique backup file name based on the original file path
func getBackupBaseName(dotenvFile string) string {
	absPath, err := filepath.Abs(dotenvFile)
	if err != nil {
		absPath = dotenvFile
	}
	
	// Create a short hash of the full path to make it unique but recognizable
	hash := sha256.Sum256([]byte(absPath))
	shortHash := hex.EncodeToString(hash[:])[:8]
	
	// Use the base filename and hash to create a recognizable name
	baseName := filepath.Base(absPath)
	return fmt.Sprintf("%s_%s", baseName, shortHash)
}

// cleanOldBackups keeps only the 3 most recent backup files for a given base name
func cleanOldBackups(stateDir, baseName string) error {
	pattern := filepath.Join(stateDir, baseName+"_*")
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return err
	}
	
	if len(matches) <= 3 {
		return nil
	}
	
	// Sort by modification time (newest first)
	sort.Slice(matches, func(i, j int) bool {
		infoI, errI := os.Stat(matches[i])
		infoJ, errJ := os.Stat(matches[j])
		if errI != nil || errJ != nil {
			return false
		}
		return infoI.ModTime().After(infoJ.ModTime())
	})
	
	// Remove old backups (keep only 3 most recent)
	for i := 3; i < len(matches); i++ {
		if err := os.Remove(matches[i]); err != nil {
			log.Warn("Failed to remove old backup", "file", matches[i], "error", err)
		}
	}
	
	return nil
}

func backup(dotenvFile string) error {
	if _, err := os.Stat(dotenvFile); err != nil {
		// File doesn't exist, nothing to backup
		return nil
	}
	
	stateDir, err := getStateDir()
	if err != nil {
		return err
	}
	
	baseName := getBackupBaseName(dotenvFile)
	timestamp := time.Now().Format()
	backupFileName := fmt.Sprintf("%s_%s", baseName, timestamp)
	backupPath := filepath.Join(stateDir, backupFileName)
	
	// Read the original file
	content, err := os.ReadFile(dotenvFile)
	if err != nil {
		return fmt.Errorf("failed to read file for backup: %w", err)
	}
	
	// Write to backup location
	if err := os.WriteFile(backupPath, content, 0644); err != nil {
		return fmt.Errorf("failed to write backup file: %w", err)
	}
	
	absPath, _ := filepath.Abs(dotenvFile)
	log.Info("Backed up file", "original", absPath, "backup", backupPath)
	
	// Clean up old backups
	if err := cleanOldBackups(stateDir, baseName); err != nil {
		log.Warn("Failed to clean old backups", "error", err)
	}
	
	return nil
}

func readTemplate(dotenvFile string) ([]string, string) {
	templateFiles := []string{
		dotenvFile,
		dotenvFile + sampleSuffix,
		dotenvFile + templateSuffix,
	}

	for _, templateFile := range templateFiles {
		templateContents, err := os.ReadFile(templateFile)
		if err != nil {
			log.Debug(err)
			continue
		}

		if len(templateContents) == 0 {
			continue
		}

		log.Info("Using " + templateFile + " as template")

		return slices.Collect(strings.Lines(string(templateContents))), templateFile
	}

	return slices.Collect(strings.Lines(defaultEnvTemplate)), ""
}

func variablesFromTemplate(templateLines []string) ([]variable, string, bool) {
	variables := make([]variable, 0)
	changed := false

	var contents strings.Builder

	for _, templateLine := range templateLines {
		v := newFromLine(templateLine)

		if v.name != "" && v.commented {
			variables = append(variables, v)
		}

		if v.name == "" || v.commented {
			contents.WriteString(templateLine)
			continue
		}

		v.setValue()

		if v.changed {
			changed = true
		}

		if v.value == "" {
			contents.WriteString(templateLine)
		} else {
			log.Info("Adding variable " + v.name)
			contents.WriteString(v.String())
		}

		variables = append(variables, v)
	}

	return variables, contents.String(), changed
}

// parseVariablesOnly parses variables from template lines without attempting to auto-populate them.
// This is used when the user manually edits the file to avoid unnecessary API calls and errors.
func parseVariablesOnly(templateLines []string) []variable {
	variables := make([]variable, 0)

	for _, templateLine := range templateLines {
		v := newFromLine(templateLine)

		if v.name != "" {
			variables = append(variables, v)
		}
	}

	return variables
}

func writeUsingTemplateFile(dotenvFile string) ([]variable, string, string, error) {
	templateLines, templateFileUsed := readTemplate(dotenvFile)

	variables, contents, anyChanged := variablesFromTemplate(templateLines)

	if anyChanged {
		err := backup(dotenvFile)
		if err != nil {
			return nil, "", "", err
		}
	}

	err := writeContents(contents, dotenvFile, templateFileUsed)
	if err != nil {
		return nil, "", "", err
	}

	return variables, contents, templateFileUsed, nil
}

func writeContents(contents, dotenvFile, templateFile string) error {
	// Strip any existing header comments from the contents
	lines := strings.Split(contents, "\n")

	filteredLines := make([]string, 0, len(lines))

	strippedHeader := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip lines that are our generated headers (at the start of the file)
		if !strippedHeader && (strings.HasPrefix(trimmed, headerPrefixAutogen) ||
			strings.HasPrefix(trimmed, headerPrefixEdited)) {
			continue
		}
		// Skip empty lines immediately after header
		if !strippedHeader && trimmed == "" {
			strippedHeader = true

			continue
		}

		strippedHeader = true

		filteredLines = append(filteredLines, line)
	}

	// Reconstruct contents without the old header
	cleanContents := strings.Join(filteredLines, "\n")

	f, err := os.Create(dotenvFile)
	if err != nil {
		return err
	}
	defer f.Close()

	timestamp := time.Now().Format(time.RFC3339)

	var header string
	if templateFile == "" {
		header = headerPrefixEdited + " on " + timestamp + "\n\n"
	} else {
		header = headerPrefixEdited + " from " + templateFile + " on " + timestamp + "\n\n"
	}

	cleanContents = header + cleanContents

	_, err = f.WriteString(cleanContents)
	if err != nil {
		return err
	}

	return nil
}
