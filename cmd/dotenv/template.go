// Copyright 2025 DataRobot, Inc. and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dotenv

import (
	"bufio"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"time"

	"github.com/datarobot/cli/internal/envbuilder"
	"github.com/datarobot/cli/internal/log"
)

const (
	// Time formats
	backupTimeFormat = "2006-01-02_15-04-05"

	// Header comment prefixes
	headerPrefixAutogen = "# Autogenerated by dr dotenv"
	headerPrefixEdited  = "# Edited using `dr dotenv`"
)

// getStateDir returns the XDG_STATE_HOME directory for the dr app
func getStateDir() (string, error) {
	// TODO Rewrite this to retrieve state dir from Viper config
	stateDir := os.Getenv("XDG_STATE_HOME")
	if stateDir == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return "", fmt.Errorf("Failed to get user home directory: %w", err)
		}

		stateDir = filepath.Join(homeDir, ".local", "state")
	}

	drStateDir := filepath.Join(stateDir, "dr", "backups")
	if err := os.MkdirAll(drStateDir, 0o755); err != nil {
		return "", fmt.Errorf("Failed to create state directory: %w", err)
	}

	return drStateDir, nil
}

// getBackupBaseName creates a unique backup file name based on the original file path
func getBackupBaseName(dotenvFile string) string {
	absPath, err := filepath.Abs(dotenvFile)
	if err != nil {
		absPath = dotenvFile
	}

	// Create a short hash of the full path to make it unique but recognizable
	hash := sha256.Sum256([]byte(absPath))
	shortHash := hex.EncodeToString(hash[:])[:8]

	// Use the base filename and hash to create a recognizable name
	baseName := filepath.Base(absPath)

	return fmt.Sprintf("%s_%s", baseName, shortHash)
}

// cleanOldBackups keeps only the 3 most recent backup files for a given base name
func cleanOldBackups(stateDir, baseName string) error {
	pattern := filepath.Join(stateDir, baseName+"_*")

	matches, err := filepath.Glob(pattern)
	if err != nil {
		return err
	}

	if len(matches) <= 3 {
		return nil
	}

	// Sort by modification time (newest first)
	sort.Slice(matches, func(i, j int) bool {
		infoI, errI := os.Stat(matches[i])

		infoJ, errJ := os.Stat(matches[j])
		if errI != nil || errJ != nil {
			return false
		}

		return infoI.ModTime().After(infoJ.ModTime())
	})

	// Remove old backups (keep only 3 most recent)
	for i := 3; i < len(matches); i++ {
		if err := os.Remove(matches[i]); err != nil {
			log.Warn("Failed to remove old backup", "file", matches[i], "error", err)
		}
	}

	return nil
}

func backup(dotenvFile string) error {
	if _, err := os.Stat(dotenvFile); err != nil {
		// File doesn't exist, nothing to backup
		return nil
	}

	stateDir, err := getStateDir()
	if err != nil {
		return err
	}

	baseName := getBackupBaseName(dotenvFile)
	timestamp := time.Now().Format(backupTimeFormat)
	backupFileName := fmt.Sprintf("%s_%s", baseName, timestamp)
	backupPath := filepath.Join(stateDir, backupFileName)

	// Read the original file
	content, err := os.ReadFile(dotenvFile)
	if err != nil {
		return fmt.Errorf("Failed to read file for backup: %w", err)
	}

	// Write to backup location
	if err := os.WriteFile(backupPath, content, 0o644); err != nil {
		return fmt.Errorf("Failed to write backup file: %w", err)
	}

	absPath, _ := filepath.Abs(dotenvFile)
	log.Info("Backed up file", "original", absPath, "backup", backupPath)

	// Clean up old backups
	if err := cleanOldBackups(stateDir, baseName); err != nil {
		log.Warn("Failed to clean old backups", "error", err)
	}

	return nil
}

func readDotenvFile(dotenvFile string) ([]string, string) {
	fileContents, err := os.ReadFile(dotenvFile)
	if errors.Is(err, os.ErrNotExist) {
		fileContents = []byte(envbuilder.DefaultDotenvFile())
	} else if err != nil {
		log.Debug(err)
		return nil, ""
	}

	fileContentsString := stripHeader(string(fileContents))
	dotenvFileLines := slices.Collect(strings.Lines(fileContentsString))

	return dotenvFileLines, fileContentsString
}

func readDotenvFileVariables(dotenvFile string) ([]envbuilder.Variable, string, error) {
	dotenvFileLines, _ := readDotenvFile(dotenvFile)

	variables, contents := envbuilder.VariablesFromLines(dotenvFileLines)

	return variables, contents, nil
}

func updateDotenvFile(dotenvFile string) ([]envbuilder.Variable, string, error) {
	dotenvFileLines, _ := readDotenvFile(dotenvFile)

	variables, contents := envbuilder.VariablesFromLines(dotenvFileLines)

	err := writeContents(contents, dotenvFile)
	if err != nil {
		return nil, "", err
	}

	return variables, contents, nil
}

func stripHeader(contents string) string {
	lines := strings.Split(contents, "\n")
	filteredLines := make([]string, 0, len(lines))
	strippedHeader := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip lines that are our generated headers (at the start of the file)
		if !strippedHeader && (strings.HasPrefix(trimmed, headerPrefixAutogen) ||
			strings.HasPrefix(trimmed, headerPrefixEdited)) {
			continue
		}
		// Skip empty lines immediately after header
		if !strippedHeader && trimmed == "" {
			strippedHeader = true

			continue
		}

		strippedHeader = true

		filteredLines = append(filteredLines, line)
	}

	return strings.Join(filteredLines, "\n")
}

func writeContents(cleanContents, dotenvFile string) error {
	old, err := os.ReadFile(dotenvFile)
	if err != nil && !errors.Is(err, os.ErrNotExist) {
		log.Debug(err)
		return err
	}

	// Strip any existing header comments from the contents
	oldContents := stripHeader(string(old))

	if oldContents != cleanContents {
		// Backup the existing file before writing
		if err := backup(dotenvFile); err != nil {
			return err
		}
	}

	f, err := os.Create(dotenvFile)
	if err != nil {
		return err
	}
	defer f.Close()

	timestamp := time.Now().Format(time.RFC3339)
	header := headerPrefixEdited + " on " + timestamp + "\n"

	cleanContents = header + cleanContents

	// Use buffered writer for efficiency
	writer := bufio.NewWriter(f)

	_, err = writer.WriteString(cleanContents)
	if err != nil {
		return err
	}

	// Flush buffer to file
	if err := writer.Flush(); err != nil {
		return err
	}

	// Sync to ensure data is written to physical storage
	if err := f.Sync(); err != nil {
		return err
	}

	return nil
}
