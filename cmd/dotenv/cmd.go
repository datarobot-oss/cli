// Copyright 2025 DataRobot, Inc. and its affiliates.
// All rights reserved.
// DataRobot, Inc. Confidential.
// This is unpublished proprietary source code of DataRobot, Inc.
// and its affiliates.
// The copyright notice above does not evidence any actual or intended
// publication of such source code.

package dotenv

import (
	"net/url"
	"os"
	"regexp"
	"slices"
	"strings"
	"time"

	"github.com/spf13/viper"

	"github.com/charmbracelet/log"
	"github.com/datarobot/cli/internal/config"
	"github.com/datarobot/cli/internal/drapi"
	"github.com/spf13/cobra"
)

var Cmd = &cobra.Command{
	Use:   "dotenv",
	Short: "Add Datarobot credentials to .env file",
	Long:  "Generate or update .env file with Datarobot credentials",
	Run:   Run,
}

var defaultEnvTemplate = `# Autogenerated by dr dotenv

DATAROBOT_ENDPOINT=
DATAROBOT_API_TOKEN=

USE_DATAROBOT_LLM_GATEWAY=
`

type variableConfig = struct {
	viperKey string
	getValue func() (string, error)
	secret   bool
}

var knownVariables = map[string]variableConfig{
	"DATAROBOT_ENDPOINT_SHORT": {
		viperKey: config.DataRobotURL,
	},
	"DATAROBOT_ENDPOINT": {
		getValue: func() (string, error) {
			fullURL, err := url.JoinPath(config.GetBaseURL(), "/api/v2")
			return fullURL, err
		},
	},
	"DATAROBOT_API_TOKEN": {
		viperKey: config.DataRobotAPIKey,
		secret:   true,
	},
	"USE_DATAROBOT_LLM_GATEWAY": {
		getValue: func() (string, error) {
			enabled, err := drapi.IsLLMGatewayEnabled()
			if err != nil {
				return "", err
			}

			if enabled {
				return "true", nil
			}
			return "false", nil
		},
	},
}

func backupAndCreate(dotenvFile string) (*os.File, error) {
	if _, err := os.Stat(dotenvFile); err == nil {
		backupFile := dotenvFile + "." + time.Now().Format(time.RFC3339)

		err = os.Rename(dotenvFile, backupFile)
		if err != nil {
			return nil, err
		}

		log.Info("Backing up " + dotenvFile + " as " + backupFile)
	}

	f, err := os.Create(dotenvFile)

	return f, err
}

func readTemplate(dotenvFile string) ([]string, string) {
	var dotenvTemplate string

	templateFiles := []string{
		dotenvFile + ".sample",
		dotenvFile + ".template",
		dotenvFile,
	}

	var templateFileUsed string

	for _, templateFile := range templateFiles {
		if _, err := os.Stat(templateFile); err != nil {
			continue
		}

		bytes, err := os.ReadFile(templateFile)
		if err != nil {
			log.Warn(err)
			continue
		}

		if len(bytes) == 0 {
			continue
		}

		log.Info("Using " + templateFile + " as template")
		dotenvHeader := "# Autogenerated by dr dotenv from " + templateFile + " file\n\n"
		dotenvTemplate = dotenvHeader + string(bytes)
		templateFileUsed = templateFile

		break
	}

	if len(dotenvTemplate) == 0 {
		return slices.Collect(strings.Lines(defaultEnvTemplate)), ""
	}

	return slices.Collect(strings.Lines(dotenvTemplate)), templateFileUsed
}

func writeVariable(f *os.File, name, value string) (string, error) {
	log.Info("Adding variable " + name)

	line := name + "=" + value + "\n"
	_, err := f.WriteString(line)
	if err != nil {
		return "", err
	}

	return line, nil
}

func variableName(line string) string {
	re := regexp.MustCompile(`^([a-zA-Z_]+[a-zA-Z0-9_]*)(\s*=\s*)?`)
	result := re.FindStringSubmatch(line)

	if len(result) > 0 {
		return result[1]
	}

	return ""
}

func writeFromTemplate(f *os.File, templateLines []string) ([]variable, string, error) {
	variables := make([]variable, 0)
	var contents strings.Builder

	for _, templateLine := range templateLines {
		name := variableName(templateLine)

		if name == "" {
			_, err := f.WriteString(templateLine)
			if err != nil {
				return nil, "", err
			}

			contents.WriteString(templateLine)
			continue
		}

		v := variable{
			name:   name,
			secret: knownVariables[name].secret,
		}

		if conf, found := knownVariables[name]; found {
			v.auto = true

			switch {
			case conf.viperKey != "":
				v.value = viper.GetString(conf.viperKey)
			case conf.getValue != nil:
				var err error

				v.value, err = conf.getValue()
				if err != nil {
					log.Error(err)
				}
			}
		}

		if v.value == "" {
			_, err := f.WriteString(templateLine)
			if err != nil {
				return nil, "", err
			}

			contents.WriteString(templateLine)
		} else {
			line, err := writeVariable(f, name, v.value)
			if err != nil {
				return nil, "", err
			}

			contents.WriteString(line)
		}

		variables = append(variables, v)
	}

	return variables, contents.String(), nil
}

func Run(_ *cobra.Command, _ []string) {
	dotenvFile := ".env"
	templateLines, _ := readTemplate(dotenvFile)

	f, err := backupAndCreate(dotenvFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, _, err = writeFromTemplate(f, templateLines)
	if err != nil {
		log.Error(err)
	}
}
