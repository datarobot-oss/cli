// Copyright 2025 DataRobot, Inc. and its affiliates.
// All rights reserved.
// DataRobot, Inc. Confidential.
// This is unpublished proprietary source code of DataRobot, Inc.
// and its affiliates.
// The copyright notice above does not evidence any actual or intended
// publication of such source code.

package dotenv

import (
	"os"
	"regexp"
	"slices"
	"strings"
	"time"

	"github.com/charmbracelet/log"
	"github.com/datarobot/cli/cmd/auth"
	"github.com/datarobot/cli/internal/config"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var Cmd = &cobra.Command{
	Use:   "dotenv",
	Short: "Add Datarobot credentials to .env file",
	Long:  "Generate or update .env file with Datarobot credentials",
	Run:   Run,
}

var defaultEnvTemplate = `# Autogenerated by dr dotenv

DATAROBOT_ENDPOINT=
DATAROBOT_API_TOKEN=
`

type variableConfig = struct {
	viperKey string
	getValue func() (string, error)
	secret   bool
}

var knownVariables = map[string]variableConfig{
	"DATAROBOT_ENDPOINT_SHORT": {
		getValue: func() (string, error) {
			datarobotHost, err := auth.GetURL(false)
			return datarobotHost, err
		},
	},
	"DATAROBOT_ENDPOINT": {
		viperKey: config.DataRobotURL,
	},
	"DATAROBOT_API_TOKEN": {
		viperKey: config.DataRobotAPIKey,
		secret:   true,
	},
}

func backupAndCreate(dotenvFile string) (*os.File, error) {
	if _, err := os.Stat(dotenvFile); err == nil {
		backupFile := dotenvFile + "." + time.Now().Format(time.RFC3339)

		err = os.Rename(dotenvFile, backupFile)
		if err != nil {
			return nil, err
		}

		log.Info("Backing up " + dotenvFile + " as " + backupFile)
	}

	f, err := os.Create(dotenvFile)

	return f, err
}

func readTemplate(dotenvFile string) ([]string, string) {
	var dotenvTemplate string

	templateFiles := []string{
		dotenvFile + ".sample",
		dotenvFile + ".template",
		dotenvFile,
	}

	var templateFileUsed string

	for _, templateFile := range templateFiles {
		if _, err := os.Stat(templateFile); err != nil {
			continue
		}

		bytes, err := os.ReadFile(templateFile)
		if err != nil {
			log.Warn(err)
			continue
		}

		if len(bytes) == 0 {
			continue
		}

		log.Info("Using " + templateFile + " as template")
		dotenvHeader := "# Autogenerated by dr dotenv from " + templateFile + " file\n\n"
		dotenvTemplate = dotenvHeader + string(bytes)
		templateFileUsed = templateFile

		break
	}

	if len(dotenvTemplate) == 0 {
		return slices.Collect(strings.Lines(defaultEnvTemplate)), ""
	}

	return slices.Collect(strings.Lines(dotenvTemplate)), templateFileUsed
}

func writeVariable(f *os.File, name, value string) error {
	log.Info("Adding variable " + name)

	_, err := f.WriteString(name + "=" + value + "\n")

	return err
}

func variableName(line string) string {
	re := regexp.MustCompile(`^([a-zA-Z_]+[a-zA-Z0-9_]*)(\s*=\s*)?`)
	result := re.FindStringSubmatch(line)

	if len(result) > 0 {
		return result[1]
	}

	return ""
}

func writeFromTemplate(f *os.File, templateLines []string) ([]variable, error) {
	variables := make([]variable, 0)

	for _, templateLine := range templateLines {
		name := variableName(templateLine)

		var value string

		if name != "" {
			if conf, found := knownVariables[name]; found {
				switch {
				case conf.viperKey != "":
					value = viper.GetString(conf.viperKey)
				case conf.getValue != nil:
					var err error

					value, err = conf.getValue()
					if err != nil {
						log.Error(err)
					}
				}
			}
		}

		if value != "" {
			variables = append(variables, variable{
				name:   name,
				value:  value,
				secret: knownVariables[name].secret,
			})

			err := writeVariable(f, name, value)
			if err != nil {
				return nil, err
			}
		} else {
			_, err := f.WriteString(templateLine)
			if err != nil {
				return nil, err
			}
		}
	}

	return variables, nil
}

func Run(_ *cobra.Command, _ []string) {
	dotenvFile := ".env"
	templateLines, _ := readTemplate(dotenvFile)

	f, err := backupAndCreate(dotenvFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = writeFromTemplate(f, templateLines)
	if err != nil {
		log.Error(err)
	}
}
